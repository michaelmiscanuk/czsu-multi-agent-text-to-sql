"""
MODULE_DESCRIPTION: Request Models - Pydantic Schemas for API Request Validation

===================================================================================
PURPOSE AND OVERVIEW
===================================================================================

This module defines Pydantic BaseModel classes that serve as request schemas for
the CZSU Multi-Agent Text-to-SQL API. These models provide automatic request
validation, type checking, and OpenAPI documentation generation for all incoming
API requests.

Request Models:
    1. AnalyzeRequest: Natural language query analysis requests
    2. FeedbackRequest: User feedback submission for query results
    3. SentimentRequest: Quick sentiment tracking (positive/negative)

Note on run_id:
    The run_id field identifies the root run of a LangGraph execution.
    In LangSmith, this root run ID also serves as the trace identifier,
    allowing feedback to be attached to the complete execution trace.

Each model includes:
    - Field definitions with types and constraints
    - Custom validators for business logic
    - OpenAPI examples for documentation
    - Automatic serialization/deserialization

===================================================================================
KEY FEATURES
===================================================================================

1. Automatic Validation
   - Field type checking
   - Length constraints
   - Value range validation
   - Custom business logic validation

2. UUID Validation
   - Ensures run_id fields are valid UUIDs
   - Prevents malformed identifiers
   - Supports optional run_id values

3. Input Sanitization
   - Whitespace trimming
   - Empty string handling
   - Null value normalization

4. OpenAPI Integration
   - Automatic schema generation
   - Example requests in documentation
   - Field descriptions for clients

5. Error Messages
   - Clear validation error messages
   - Field-level error reporting
   - Client-friendly feedback

===================================================================================
REQUEST MODELS
===================================================================================

Model 1: AnalyzeRequest
    Purpose: Submit natural language queries for AI analysis

    Fields:
        prompt (str):
            - User's natural language question
            - Min length: 1 character
            - Max length: 10,000 characters
            - Required field
            - Automatically trimmed
            - Example: "What was the population of Prague in 2020?"

        thread_id (str):
            - Unique conversation thread identifier
            - Min length: 1 character
            - Max length: 100 characters
            - Required field
            - Automatically trimmed
            - Example: "thread_abc123"

        run_id (Optional[str]):
            - Optional UUID for run tracking
            - Must be valid UUID format if provided
            - Auto-generated by backend if not provided
            - Automatically trimmed
            - Example: "550e8400-e29b-41d4-a716-446655440000"

    Validators:
        - validate_prompt: Ensures non-empty, trims whitespace
        - validate_thread_id: Ensures non-empty, trims whitespace
        - validate_run_id: Validates UUID format, trims whitespace

    Usage:
        POST /analyze
        {
            "prompt": "Show unemployment rates for 2023",
            "thread_id": "thread_12345",
            "run_id": "550e8400-e29b-41d4-a716-446655440000"
        }

Model 2: FeedbackRequest
    Purpose: Submit user feedback on AI query results

    Fields:
        run_id (str):
            - UUID of the analysis run being reviewed
            - Required field
            - Must be valid UUID format
            - Links feedback to specific query
            - Example: "550e8400-e29b-41d4-a716-446655440000"

        feedback (Optional[int]):
            - Binary rating: 1 = thumbs up, 0 = thumbs down
            - Range: 0-1 inclusive
            - Optional (can submit comment only)
            - Example: 1

        comment (Optional[str]):
            - Text feedback explaining the rating
            - Max length: 1,000 characters
            - Optional (can submit rating only)
            - Empty strings converted to None
            - Example: "The query results were accurate and helpful."

    Validators:
        - validate_run_id: Validates UUID format, ensures non-empty
        - validate_comment: Converts empty strings to None

    Usage:
        POST /feedback
        {
            "run_id": "550e8400-e29b-41d4-a716-446655440000",
            "feedback": 1,
            "comment": "Great results!"
        }

Model 3: SentimentRequest
    Purpose: Track user sentiment (simpler than FeedbackRequest)

    Fields:
        run_id (str):
            - UUID of the analysis run
            - Required field
            - Must be valid UUID format
            - Example: "550e8400-e29b-41d4-a716-446655440000"

        sentiment (Optional[bool]):
            - true: Positive sentiment
            - false: Negative sentiment
            - null: Clear/remove sentiment
            - Example: true

    Validators:
        - validate_run_id: Validates UUID format, ensures non-empty

    Usage:
        POST /sentiment
        {
            "run_id": "550e8400-e29b-41d4-a716-446655440000",
            "sentiment": true
        }

===================================================================================
FIELD VALIDATION
===================================================================================

Pydantic Field Constraints:
    - min_length: Minimum string length
    - max_length: Maximum string length
    - ge (greater or equal): Minimum numeric value
    - le (less or equal): Maximum numeric value
    - description: Field documentation
    - examples: Example values for OpenAPI

Custom Validators:
    @field_validator("field_name")
    @classmethod
    def validate_field_name(cls, v):
        # Custom validation logic
        # Raise ValueError if invalid
        # Return processed value
        return v

Validation Order:
    1. Type checking (Pydantic built-in)
    2. Field constraints (min_length, etc.)
    3. Custom validators (@field_validator)

Error Response (422):
    {
        "detail": "Validation error",
        "errors": [
            {
                "loc": ["body", "prompt"],
                "msg": "Prompt cannot be empty or only whitespace",
                "type": "value_error"
            }
        ]
    }

===================================================================================
UUID VALIDATION
===================================================================================

Purpose:
    - Ensures run_id fields are valid UUIDs
    - Prevents malformed identifiers
    - Maintains data consistency

Validation Logic:
    1. Check for None (allowed for optional fields)
    2. Check for empty/whitespace-only strings
    3. Try to parse with uuid.UUID()
    4. Raise ValueError if invalid
    5. Return trimmed string

Example Valid UUIDs:
    - "550e8400-e29b-41d4-a716-446655440000"
    - "6ba7b810-9dad-11d1-80b4-00c04fd430c8"

Example Invalid UUIDs:
    - "not-a-uuid"
    - "123"
    - "550e8400-e29b-41d4-a716"  # Too short

Error Message:
    "Run ID must be a valid UUID format"

===================================================================================
INPUT SANITIZATION
===================================================================================

Whitespace Trimming:
    prompt = "  Hello world  "
    After validation: "Hello world"

    Applies to:
        - prompt (AnalyzeRequest)
        - thread_id (AnalyzeRequest)
        - run_id (all models)

Empty String Handling:
    comment = "   "  # Whitespace only
    After validation: None

    Applies to:
        - comment (FeedbackRequest)

Benefits:
    - Consistent data format
    - Prevents accidental whitespace
    - Better database queries
    - Cleaner UI display

===================================================================================
OPENAPI INTEGRATION
===================================================================================

Schema Generation:
    Pydantic models automatically generate OpenAPI schemas
    Visible in /docs (Swagger UI)

Field Documentation:
    description parameter ‚Üí Field description in docs
    examples parameter ‚Üí Example values in docs

Model Examples:
    model_config = {
        "json_schema_extra": {
            "examples": [...]
        }
    }

    Shows complete request examples in Swagger UI

Try It Out:
    Users can test API with examples from /docs
    Pre-filled request bodies
    Interactive testing

===================================================================================
ERROR HANDLING
===================================================================================

Validation Errors:
    - Raised as RequestValidationError by Pydantic
    - Caught by validation_exception_handler
    - Returned as 422 Unprocessable Entity
    - Includes field-level error details

Custom Validation Errors:
    raise ValueError("Custom error message")

    Converted to:
    {
        "loc": ["body", "field_name"],
        "msg": "Custom error message",
        "type": "value_error"
    }

Multiple Errors:
    Pydantic collects ALL validation errors
    Returns all errors in single response
    Client can fix all issues at once

===================================================================================
TESTING CONSIDERATIONS
===================================================================================

Unit Tests:
    - Test each validator function
    - Test field constraints
    - Test valid/invalid inputs
    - Test edge cases

Test Examples:
    def test_analyze_request_valid():
        request = AnalyzeRequest(
            prompt="Test query",
            thread_id="thread_123",
            run_id="550e8400-e29b-41d4-a716-446655440000"
        )
        assert request.prompt == "Test query"

    def test_analyze_request_empty_prompt():
        with pytest.raises(ValueError):
            AnalyzeRequest(
                prompt="   ",  # Whitespace only
                thread_id="thread_123"
            )

    def test_feedback_request_invalid_uuid():
        with pytest.raises(ValueError):
            FeedbackRequest(
                run_id="not-a-uuid",
                feedback=1
            )

Integration Tests:
    - Test full API endpoints
    - Verify 422 response format
    - Test example requests from docs

===================================================================================
DEPENDENCIES
===================================================================================

Standard Library:
    - os: Environment variables
    - sys: Platform detection
    - uuid: UUID validation

Third-Party:
    - pydantic: BaseModel, Field, field_validator
    - dotenv: Environment variable loading

===================================================================================
FUTURE ENHANCEMENTS
===================================================================================

1. Additional Validators
   - Email format validation
   - URL validation
   - Date/time validation

2. Enhanced Feedback
   - Star ratings (1-5)
   - Multi-category feedback
   - Structured feedback data

3. Request Versioning
   - API version in request
   - Backward compatibility
   - Gradual migration

4. Advanced Validation
   - Cross-field validation
   - Conditional requirements
   - Complex business rules

===================================================================================
"""

# Request models for the CZSU multi-agent text-to-SQL API
# CRITICAL: Set Windows event loop policy FIRST, before any other imports
# This must be the very first thing that happens to fix psycopg compatibility
import os
import sys

if sys.platform == "win32":
    import asyncio

    asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())

# Load environment variables early
from dotenv import load_dotenv

load_dotenv()

# Constants
try:
    from pathlib import Path

    BASE_DIR = Path(__file__).resolve().parents[2]
except NameError:
    BASE_DIR = Path(os.getcwd()).parents[0]

# Standard imports
import uuid
from typing import Optional

from pydantic import BaseModel, Field, field_validator

# ==============================================================================
# REQUEST MODELS - PYDANTIC SCHEMAS FOR API VALIDATION
# ==============================================================================


class AnalyzeRequest(BaseModel):
    """Request model for analyzing natural language queries.

    This model represents a user's natural language question that will be
    converted to SQL and executed against the CZSU database. It validates
    the input prompt, thread identifier, and optional run ID.

    Validation Rules:
        - prompt: Non-empty, max 10,000 characters, whitespace trimmed
        - thread_id: Non-empty, max 100 characters, whitespace trimmed
        - run_id: Optional, must be valid UUID if provided

    Example Request:
        POST /analyze
        {
            "prompt": "Show unemployment rates for 2023",
            "thread_id": "thread_12345",
            "run_id": "550e8400-e29b-41d4-a716-446655440000"
        }
    """

    # =======================================================================
    # FIELD DEFINITIONS
    # =======================================================================

    prompt: str = Field(
        ...,  # Required field
        min_length=1,  # At least 1 character (after whitespace trimming)
        max_length=10000,  # Max 10,000 characters to prevent abuse
        description="Natural language query to analyze and convert to SQL",
        examples=["What was the population of Prague in 2020?"],
    )
    thread_id: str = Field(
        ...,  # Required field
        min_length=1,  # At least 1 character
        max_length=100,  # Reasonable limit for thread IDs
        description="Unique identifier for the conversation thread",
        examples=["thread_abc123"],
    )
    run_id: Optional[str] = Field(
        None,  # Optional field (auto-generated if not provided)
        min_length=1,  # If provided, must be non-empty
        description=(
            "Optional run ID in UUID format for LangSmith tracing. "
            "Passed to LangGraph as the root run identifier. "
            "Auto-generated if not provided."
        ),
        examples=["550e8400-e29b-41d4-a716-446655440000"],
    )

    # =======================================================================
    # OPENAPI CONFIGURATION
    # =======================================================================

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "prompt": "Show me unemployment rates for 2023",
                    "thread_id": "thread_12345",
                    "run_id": "550e8400-e29b-41d4-a716-446655440000",
                }
            ]
        }
    }

    # =======================================================================
    # CUSTOM VALIDATORS
    # =======================================================================

    @field_validator("prompt")
    @classmethod
    def validate_prompt(cls, v):
        """Validate that prompt is non-empty after trimming whitespace.

        Ensures users cannot submit empty or whitespace-only prompts.
        Automatically trims leading/trailing whitespace for cleaner data.

        Args:
            v: The prompt value to validate

        Returns:
            Trimmed prompt string

        Raises:
            ValueError: If prompt is empty or only whitespace
        """
        if not v or not v.strip():
            raise ValueError("Prompt cannot be empty or only whitespace")
        return v.strip()

    @field_validator("thread_id")
    @classmethod
    def validate_thread_id(cls, v):
        """Validate that thread_id is non-empty after trimming whitespace.

        Ensures thread identifiers are valid and trimmed for consistency.

        Args:
            v: The thread_id value to validate

        Returns:
            Trimmed thread_id string

        Raises:
            ValueError: If thread_id is empty or only whitespace
        """
        if not v or not v.strip():
            raise ValueError("Thread ID cannot be empty or only whitespace")
        return v.strip()

    @field_validator("run_id")
    @classmethod
    def validate_run_id(cls, v):
        """Validate that run_id is a valid UUID string if provided.

        Optional field - can be None. If provided, must be valid UUID format.
        This run_id is passed to LangGraph and used for LangSmith tracing.

        Args:
            v: The run_id value to validate (can be None)

        Returns:
            Trimmed run_id string or None

        Raises:
            ValueError: If run_id is provided but empty or invalid UUID format
        """
        if v is not None:
            if not v or not v.strip():
                raise ValueError("Run ID cannot be empty")
            # Basic UUID format validation using standard library
            try:
                uuid.UUID(v.strip())
            except ValueError as exc:
                raise ValueError("Run ID must be a valid UUID format") from exc
            return v.strip()
        return v


class FeedbackRequest(BaseModel):
    """Request model for submitting user feedback on query results.

    Allows users to rate AI responses (thumbs up/down) and optionally provide
    text comments. Feedback is tracked in LangSmith for quality monitoring
    and model improvement.

    Validation Rules:
        - run_id: Required, must be valid UUID
        - feedback: Optional, must be 0 or 1 if provided
        - comment: Optional, max 1,000 characters, empty strings converted to None

    Flexible Submission:
        - Rating only: {"run_id": "...", "feedback": 1}
        - Comment only: {"run_id": "...", "comment": "..."}
        - Both: {"run_id": "...", "feedback": 1, "comment": "..."}

    Example Request:
        POST /feedback
        {
            "run_id": "550e8400-e29b-41d4-a716-446655440000",
            "feedback": 1,
            "comment": "Great results!"
        }
    """

    # =======================================================================
    # FIELD DEFINITIONS
    # =======================================================================

    run_id: str = Field(
        ...,  # Required field
        min_length=1,  # Must be non-empty
        description="UUID of the analysis run to provide feedback for",
        examples=["550e8400-e29b-41d4-a716-446655440000"],
    )
    feedback: Optional[int] = Field(
        None,  # Optional field
        ge=0,  # Greater or equal to 0
        le=1,  # Less or equal to 1
        description="Binary feedback score: 1 = positive (üëç), 0 = negative (üëé)",
        examples=[1],
    )
    comment: Optional[str] = Field(
        None,  # Optional field
        max_length=1000,  # Limit to prevent abuse
        description="Optional text comment explaining the feedback",
        examples=["The query results were accurate and helpful."],
    )

    # =======================================================================
    # OPENAPI CONFIGURATION
    # =======================================================================

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "run_id": "550e8400-e29b-41d4-a716-446655440000",
                    "feedback": 1,
                    "comment": "Great results!",
                }
            ]
        }
    }

    # =======================================================================
    # CUSTOM VALIDATORS
    # =======================================================================

    @field_validator("run_id")
    @classmethod
    def validate_run_id(cls, v):
        """Validate that run_id is a non-empty valid UUID string.

        Links feedback to specific analysis run for tracking and correlation.

        Args:
            v: The run_id value to validate

        Returns:
            Trimmed run_id string

        Raises:
            ValueError: If run_id is empty or invalid UUID format
        """
        if not v or not v.strip():
            raise ValueError("Run ID cannot be empty")

        try:
            uuid.UUID(v.strip())
        except ValueError as exc:
            raise ValueError("Run ID must be a valid UUID format") from exc
        return v.strip()

    @field_validator("comment")
    @classmethod
    def validate_comment(cls, v):
        """Convert empty comment strings to None.

        Normalizes empty/whitespace-only comments to None for cleaner data.
        Allows distinction between "no comment" and actual comment.

        Args:
            v: The comment value to validate

        Returns:
            Comment string or None
        """
        if v is not None and len(v.strip()) == 0:
            return None  # Convert empty string to None
        return v


class SentimentRequest(BaseModel):
    """Request model for tracking user sentiment on query responses.

    Simpler alternative to FeedbackRequest for quick positive/negative tracking.
    Supports setting sentiment (true/false) or clearing it (null).

    Validation Rules:
        - run_id: Required, must be valid UUID
        - sentiment: Optional boolean (true/false/null)

    Sentiment Values:
        - true: Positive reaction (üëç)
        - false: Negative reaction (üëé)
        - null: Clear/remove sentiment

    Example Request:
        POST /sentiment
        {
            "run_id": "550e8400-e29b-41d4-a716-446655440000",
            "sentiment": true
        }
    """

    # =======================================================================
    # FIELD DEFINITIONS
    # =======================================================================

    run_id: str = Field(
        ...,  # Required field
        min_length=1,  # Must be non-empty
        description="UUID of the analysis run to track sentiment for",
        examples=["550e8400-e29b-41d4-a716-446655440000"],
    )
    sentiment: Optional[bool] = Field(
        None,  # Optional field
        description=(
            "Sentiment value: true = positive, false = negative, "
            "null = clear/remove sentiment"
        ),
        examples=[True],
    )

    # =======================================================================
    # OPENAPI CONFIGURATION
    # =======================================================================

    model_config = {
        "json_schema_extra": {
            "examples": [
                {"run_id": "550e8400-e29b-41d4-a716-446655440000", "sentiment": True}
            ]
        }
    }

    # =======================================================================
    # CUSTOM VALIDATORS
    # =======================================================================

    @field_validator("run_id")
    @classmethod
    def validate_run_id(cls, v):
        """Validate that run_id is a non-empty valid UUID string.

        Links sentiment to specific analysis run for tracking.

        Args:
            v: The run_id value to validate

        Returns:
            Trimmed run_id string

        Raises:
            ValueError: If run_id is empty or invalid UUID format
        """
        if not v or not v.strip():
            raise ValueError("Run ID cannot be empty")

        try:
            uuid.UUID(v.strip())
        except ValueError as exc:
            raise ValueError("Run ID must be a valid UUID format") from exc
        return v.strip()
